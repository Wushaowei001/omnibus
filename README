h2. Introduction 

omnibus helps you build self-installing, full-stack software builds.  For
example, we want to distribute the Chef client pre-bundled with its
dependencies: ruby, required gems, etc.  The result is a single installable
shell-script that can be executed on the client side, installing Chef, and
configuring it.

omnibus starts with the idea of a "project", which is comprised of a name,
version, and a build order.  The build order references various "software"
packages, which are compiled and installed to a specific path on the
filesystem. (For the chef-full project, this would be /opt/opscode).  

h2. Using omnibus

To start using omnibus, you need a few dependencies:

* Java - either the Sun JDK, or the Open JDK
* Leiningen
* Your operating systems base build utilities - gcc, autoconf, etc.

To install Leiningen, follow the instructions here: http://github.com/technomancy/leiningen

Once you have Leiningen installed, run:

$ lein deps

From the top of the omnibus source tree.

To start a build:
(make sure the project includes the 'prep' step which will create the appropriate directories)

$ lein repl
omnibus.core=> (build-fat-binary "chef-full")

The results will be in ./pkg when the build is complete.

h2. Adding software to omnibus

To add new software to omnibus, you want to extract it and commit the source in the './source' directory.  Then add a configuration to config/software.  For example, to build gdbm:

  1. Download the source for gdbm-1.8.3
  2. Unpacked it in ./source
  3. Removed the tarball
  4. Added the following configuration in config/software/gdbm.clj

(software "gdbm" :source "gdbm-1.8.3"
                 :steps [["./configure" "--prefix=/opt/opscode/embedded"]
                         (if (is-os? "darwin") ["perl" "-pi" "-e" "s/BINOWN = bin/BINOWN = root/g" "Makefile"])
                         (if (is-os? "darwin") ["perl" "-pi" "-e" "s/BINGRP = bin/BINGRP = wheel/g" "Makefile"])
                         ["make"]
                         ["sudo" "make" "install"]])
  
The :source field should be the name of the directory created by unpacking the tarball.  The steps are a vector of vectors, each of which corresponds to a build step.  These steps are passed directly to clojure.java.sh/sh, which will execute them directly. You can use two handy functions to make the build be different based on operating system or machine architecture: is-os? and is-machine?.

h2. Adding software to a project

In config/projects, you will find the actual project definitions themselves.  These contain a name for the project, a version number, and the build order.  For the chef client:

(project 
  "chef-full" 
  "0.9.8" 
  [ "zlib" "libiconv" "db" "gdbm" "ncurses" "openssl" "libxml2" "libxslt" "ree" "rubygems" "rsync" "chef" ])

The build order will run in order.

Enjoy!

h2. Bundled software and licensing

All software under the "source" directory retains the license by which it was originally distributed.
